## 什么是Synchronized
Synchronized是一种悲观锁的实现,使用Synchronized获取对象的锁后,线程只有在离开同步代码块或者调用该对象的wait()方法才会释放锁,否则其他线程将无法访问被Synchronized关键字包围的代码.  
说Synchronized是悲观锁是因为线程认为它在执行代码时有其它线程会打断它并同时修改共享数据,所有使用Synchronized保证同一时间内只有一个线程能执行.



## 什么是CAS
 Compare and Swap即比较并替换.
 java.util.concurrent包中借助CAS实现了区别于synchronouse同步锁的一种乐观锁。  
 CAS依赖于处理器的底层实现原语保证CAS本身是原子性的操作.  
 `CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。`  
## 为什么要用CAS  
在某些场景中,线程对于共享资源的竞争不是很激烈,但线程使用共享资源的时间又非常短,这时候用Synchronized是非常不合适的.因为使用Synchronized会频繁的切换上下文让执行的线程被阻塞并被挂起,而这种操作消耗的时间远大于共享资源使用的时间的时候就应该使用CAS . 
## CAS的缺点  
1.  **ABA问题**。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
2. **循环时间长开销大**。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

3. **只能保证一个共享变量的原子操作**。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。  



## 总结  
1、使用CAS在线程冲突严重时，会大幅降低程序性能；**CAS只适合于线程冲突较少的情况使用**。  
2、synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。
