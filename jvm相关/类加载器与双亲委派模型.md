## 什么是类加载器
 在java中,类加载器用于实现类的加载到内存的动作,换句话说,我们所编写的`.class`文件都需要类加载器来进行加载.
 但它在java程序中起到的作用却不止于此.  
 对于任意一个类,都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性,每一个类是否加载都需要拥有一个独立的名称空间,换句话说:`比较两个类是否'相等',首先就必须是同一个类加载器加载的`，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。  

## 双亲委派模型  
了解了类加载器,再来聊聊都有哪些类加载器.
类加载器可以细分为:
- **启动（Bootstrap）类加载器**：使用c++实现,负责将 Java_Home/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。

- **标准扩展（Extension）类加载器**：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将Java_Home /lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。

- **应用程序（Application）类加载器**：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统（System）加载器。  

### 双亲委派模型过程
双亲委派模型的工作过程为：  
`如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成`，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。  

### 我们可以自己写一个String类吗?
如果自己写一个叫java.lang.String的类能使用吗?  
答案是`可以编译成功,但永远不会被运行.`  
String类位于rt.jar中,当用户使用到String类将首先请求Bootstrap类加载器加载rt.jar中的类,所以自己编写的String类将永远无法得到运行与加载.
