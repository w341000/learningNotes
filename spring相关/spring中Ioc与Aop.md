## Ioc Inversion of Control 控制反转  
**依赖倒置的说明:**
高层模块不依赖与底层模块，两者应该依赖抽象，抽象不应该依赖于实现，实现应依赖于抽象。  
Ioc容器主要有以下功能：  
 动态创建 注入依赖对象，管理对象生命周期，映射依赖关系。   
**控制反转** 是关于对象如何获得它依赖对象的引用，反转指的是权利的反转。对象依赖关系的管理被反转了，转到ioc容器当中了。在面向对象编程中，例如创建对象，为对象赋值引用等操作，统一由容器实现。  

首先要明确,spring本身是一个大工厂,它管理了我们所有的业务类,所谓依赖注入就是程序中需要用到某一个
类的实例时,不再是自己new了,而是让spring给我们注入.那么为什么不自己new呢?为什么要让spring来管理一切呢?  
试想类A和类B引用到了类C的实例,此时它们只能靠自己这样来获得:`new c();`,ok,这没问题,有一天我新建了一个C的子类D,并且我希望A与B都使用D,那么需要修改A与B的源代码,将`new C();`修改为`new D();`  
现在,看出问题了吗?当创建的类很多时,这种修改的代价是非常昂贵的.而让spring帮我们注入,则只需要在配置文件中修改一下即可,多方便!


## AOP 面向切面编程  
试想一下,你在一个庞大无比的系统中进行开发工作,有一天你接到一个任务,为每个方法的都写上日志实现,这时你写啊写啊,心里想到要是有一种办法能把所有调用方法的请求都拦截下来就好了,由我来实现方法该不该继续往下调用!由我来在方法调用前后做一些事情!  
没错,这就是AOP,面向切面编程,你的关注点是日志实现,你不在乎是哪个类的哪个方法,你只需要在它们调用前后加上日志功能. 设计模式中的责任链便是AOP的体现之一,责任链让请求在处理之前有机会被其他方法处理.
