## Ioc Inversion of Control 控制反转
作为同样概念的还有依赖注入.
那么什么是依赖注入或控制反转呢?  
首先要明确,spring本身是一个大工厂,它管理了我们所有的业务类,所谓依赖注入就是程序中需要用到某一个
类的实例时,不再是自己new了,而是让spring给我们注入.那么为什么不自己new呢?为什么要让spring来管理一切呢?  
试想类A和类B引用到了类C的实例,此时它们只能靠自己这样来获得:`new c();`,ok,这没问题,有一天我新建了一个C的子类D,并且我希望A与B都使用D,那么需要修改A与B的源代码,将`new C();`修改为`new D();`  
现在,看出问题了吗?当创建的类很多时,这种修改的代价是非常昂贵的.而让spring帮我们注入,则只需要在配置文件中修改一下即可,多方便!


## AOP 面向切面编程  
试想一下,你在一个庞大无比的系统中进行开发工作,有一天你接到一个任务,为每个方法的都写上日志实现,这时你写啊写啊,心里想到要是有一种办法能把所有调用方法的请求都拦截下来就好了,由我来实现方法该不该继续往下调用!由我来在方法调用前后做一些事情!  
没错,这就是AOP,面向切面编程,你的关注点是日志实现,你不在乎是哪个类的哪个方法,你只需要在它们调用前后加上日志功能. 设计模式中的责任链便是AOP的体现之一,责任链让请求在处理之前有机会被其他方法处理.
